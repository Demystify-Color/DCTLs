/*
	Written by Nico Wieseneder, www.demystify-color.com
	
	Original C++ code for OKLAB by Bj√∂rn Ottosson https://bottosson.github.io/posts/oklab/
	
	Thanks a ton to Matthias Stoopman (https://www.matthiasstoopman.com/) who provided me with the
	Cubic Root Function (cbrtf), sourced from: https://www.delftstack.com/howto/python/python-cube-root/
	
	Learned a lot of coding by reading through DCTLs from Jed Smith (https://github.com/jedypod/).
	I also used a lot of tools from him to verify that my matrices and conversions are correct.
	LCH(ab) implementation into OKLAB idea sourced from Jed too. 
	
	Adapted the direction switch from Quinn Leiho's Cone Coordinates DCTL which can be found here:
	(https://liftgammagain.com/forum/index.php?threads/spherical-coordinates-color-space-dctl.16898/)
	
	LCH(ab) math found at http://brucelindbloom.com/
	
	Radian To Degree Conversion adapted by myself from: https://www.geeksforgeeks.org/program-convert-radian-degree/?ref=lbp
*/


__DEVICE__ float cbrtf(float x, float cube_root) {

	if (x < 0.0f){
	x = _fabs(x);
	cube_root = _powf(x, 1.0f/3.0f)*(-1.0f);
	} else cube_root = _powf(x, 1.0f/3.0f);
	
return cube_root;

}


__DEVICE__ float3 awg_to_lch(float3 rgb) {
	
	// ALEXA Wide Gamut RGB To CIE 1931 XYZ
		const float rawg = (rgb.x * 0.63800764f) + (rgb.y * 0.21470386f) + (rgb.z * 0.09774445f);
		const float gawg = (rgb.x * 0.29195377f) + (rgb.y * 0.82384104f) + (rgb.z * -0.11579482f);
		const float bawg = (rgb.x * 0.00279827f) + (rgb.y * -0.06703423f) + (rgb.z * 1.15329373f);

	// CIE 1931 XYZ To LMS
		const float l = (rawg * 0.8189330101f) + (gawg * 0.3618667424f) + (bawg * -0.1288597137f);
		const float m = (rawg * 0.0329845436f) + (gawg * 0.9293118715f) + (bawg * 0.0361456387f);
		const float s = (rawg * 0.0482003018f) + (gawg * 0.2643662691f) + (bawg * 0.6338517070f);
			
	// LMS Non-Linearity 	
		const float l_prime = cbrtf(l,0.0f);	
		const float m_prime = cbrtf(m,0.0f);	
		const float s_prime = cbrtf(s,0.0f);

	// LMS Non-Linearity To OKLAB
		const float l_lab = (l_prime * 0.2104542553f) + (m_prime * 0.7936177850f) + (s_prime * -0.0040720468f);
		const float a_lab = (l_prime * 1.9779984951f) + (m_prime * -2.4285922050f) + (s_prime * 0.4505937099f);
		const float b_lab = (l_prime * 0.0259040371f) + (m_prime * 0.7827717662f) + (s_prime * -0.8086757660f);
		
	// OKLAB To LCH(ab)
		float pi = 3.14159265359f;
		
		float lch_l = l_lab;
		float lch_c = _sqrtf((a_lab * a_lab) + (b_lab * b_lab));
		float lch_h = _atan2f(b_lab, a_lab) * (180.f/pi);
		
		if (lch_h < 0.f) {
			lch_h = lch_h + 360.f;
		}
		
		return make_float3(lch_l, lch_c, lch_h);
		
	}
	
	
__DEVICE__ float3 lch_to_awg(float3 lch) {
// LCH(ab) To OKLAB 
	float pi = 3.14159265359f;

	const float lab_l = lch.x;
	const float lab_a = lch.y * _cosf((lch.z*(pi/180.f)));
	const float lab_b = lch.y * _sinf((lch.z* (pi/180.f)));

// OKLAB To LMS Non-Linearity 
	const float l_prime = (lab_l * 1.00000000f) + (lab_a * 0.39633784f) + (lab_b * 0.21580376f);
	const float m_prime = (lab_l * 1.00000000f) + (lab_a * -0.10556135f) + (lab_b * -0.06385418f);
	const float s_prime = (lab_l * 1.00000000f) + (lab_a * -0.08948418f) + (lab_b * -1.29148555f);
	
// LMS Non-Linearity To LMS
	const float l = _powf(l_prime,3);
	const float m = _powf(m_prime,3);
	const float s = _powf(s_prime,3);
	
// LMS To CIE 1931 XYZ  
	const float rxyz = (l * 1.2270138511f) + (m * -0.55779998065f) + (s * 0.2812561489f);
	const float gxyz = (l * -0.0405801784f) + (m * 1.1122568696f) + (s * -0.0716766786f);
	const float bxyz = (l * -0.0763812845f) + (m * -0.4214819784f) + (s * 1.5861632204f);
		
// CIE 1931 XYZ To ALEXA Wide Gamut RGB 	
	const float r = (rxyz * 1.78906548f) + (gxyz * -0.48253384f) + (bxyz * -0.20007578f);
	const float g = (rxyz * -0.63984859f) + (gxyz * 1.39639986f) + (bxyz * 0.19443229f);
	const float b = (rxyz * -0.04153153f) + (gxyz * 0.08233536f) + (bxyz * 0.8788684f);
	
	return make_float3(r, g, b);
	}
		
		
DEFINE_UI_PARAMS(DIRECTION, Direction, DCTLUI_COMBO_BOX, 0, {Forward, Inverse}, {AWG to LCH(ab), LCH(ab) to AWG})
		
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
	
	float3 rgb = make_float3(p_R, p_G, p_B);
	
	switch (DIRECTION) {
		case Forward:
			rgb = awg_to_lch(rgb);

			// Normalize Hue 0-1
			rgb.z = rgb.z * (1/360.f);

			break;
		case Inverse:
		
			// Normalize Hue 0-360
			rgb.z = rgb.z * 360.f;
			
			rgb = lch_to_awg(rgb);
			break;
	}

	return rgb;
}
	
	